config:
  auditLog:
    # PAPERLESS_AUDIT_LOG_ENABLED=<bool>
    # Enables the audit trail for documents, document types, correspondents, and tags.
    # Defaults to true.
    enabled:

  authentication:
    builtin:
      # PAPERLESS_ACCOUNT_ALLOW_SIGNUPS=<bool>
      # Allow users to signup for a new Paperless-ngx account.
      # Defaults to False
      allowSignups:

      # PAPERLESS_ACCOUNT_DEFAULT_GROUPS=<comma-separated-list>
      # A list of group names that users will be added to when they sign up
      # for a new account. Groups listed here must already exist.
      # Defaults to None
      defaultGroups:

    email:
      # PAPERLESS_ACCOUNT_EMAIL_VERIFICATION=<string>
      # Determines whether email addresses are verified during signup (as performed by Django allauth).
      # See the relevant paperless settings and the allauth docs
      # Defaults to 'optional'
      # Note: If you do not have a working email server set up this will be set to 'none'.
      signupVerification:

      # PAPERLESS_ACCOUNT_EMAIL_UNKNOWN_ACCOUNTS=<bool>
      # Configures whether password reset attempts for email addresses which do not have an account
      # result in sending an email.
      # See the relevant django-allauth documentation
      # Defaults to True (from allauth)
      unknownAccounts:

    session:
      # PAPERLESS_SESSION_COOKIE_AGE=<int>
      # Login session cookie expiration. Applies if PAPERLESS_ACCOUNT_SESSION_REMEMBER is enabled.
      # See the corresponding django documentation
      # Defaults to 1209600 (2 weeks)
      cookieAge:

      # PAPERLESS_ACCOUNT_SESSION_REMEMBER=<bool>
      # If false, sessions will expire at browser close, if true will use PAPERLESS_SESSION_COOKIE_AGE
      # for expiration. See the corresponding django-allauth documentation
      # Defaults to True
      remember:

    sso:
      # PAPERLESS_SOCIAL_ACCOUNT_SYNC_GROUPS=<bool>
      # Sync groups from the third party authentication system (e.g. OIDC) to Paperless-ngx.
      # When enabled, users will be added or removed from groups based on their group membership
      # in the third party authentication system. Groups must already exist in Paperless-ngx and
      # have the same name as in the third party authentication system. Groups are updated upon
      # logging in via the third party authentication system, see the corresponding django-allauth
      # documentation.
      # In order to pass groups from the authentication system you will need to update your
      # PAPERLESS_SOCIALACCOUNT_PROVIDERS setting by adding a top-level "SCOPES" setting which
      # includes "groups", e.g.:
      #    {"openid_connect":{"SCOPE": ["openid","profile","email","groups"]...
      # Defaults to False
      accountSyncGroups:

      # PAPERLESS_SOCIALACCOUNT_ALLOW_SIGNUPS=<bool>
      # Allow users to signup for a new Paperless-ngx account using any setup third party
      # authentication systems.
      # Defaults to True
      allowSignups:

      # PAPERLESS_SOCIAL_AUTO_SIGNUP=<bool>
      # Attempt to signup the user using retrieved email, username etc from the third party
      # authentication system. See the corresponding django-allauth documentation
      # Defaults to False
      autoSignup:

      # PAPERLESS_SOCIAL_ACCOUNT_DEFAULT_GROUPS=<comma-separated-list>
      # A list of group names that users who signup via social accounts will be added to upon signup.
      # Groups listed here must already exist. If both the PAPERLESS_ACCOUNT_DEFAULT_GROUPS setting
      # and this setting are used, the user will be added to both sets of groups.
      # Defaults to None
      defaultGroups:

      # PAPERLESS_DISABLE_REGULAR_LOGIN=<bool>
      # Disables the regular frontend username / password login, i.e. once you have setup SSO.
      # Note that this setting does not disable the Django admin login nor logging in with local
      # credentials via the API. To prevent access to the Django admin, consider blocking /admin/
      # in your web server or reverse proxy configuration.
      # You can optionally also automatically redirect users to the SSO login with
      # PAPERLESS_REDIRECT_LOGIN_TO_SSO.
      # Defaults to False
      disableRegularLogin:

      # PAPERLESS_SOCIALACCOUNT_PROVIDERS=<json>
      # This variable is used to setup login and signup via social account providers which are
      # compatible with django-allauth. See the corresponding django-allauth documentation for a list
      # of provider configurations. You will also need to include the relevant Django 'application'
      # inside the PAPERLESS_APPS setting to activate that specific authentication provider
      # (e.g. allauth.socialaccount.providers.openid_connect for the OIDC Connect provider).
      # Defaults to None, which does not enable any third party authentication systems.
      providers:

      # PAPERLESS_REDIRECT_LOGIN_TO_SSO=<bool>
      # When this setting is enabled users will automatically be redirected (using javascript) to the
      # first SSO provider login. You may still want to disable the frontend login form for clarity.
      # Defaults to False
      redirectLogin:

  barcodes:
    # PAPERLESS_CONSUMER_ASN_BARCODE_PREFIX=<string>
    # Defines the prefix that is used to identify a barcode as an ASN barcode.
    # Defaults to "ASN"
    asnBarcodePrefix:

    # PAPERLESS_CONSUMER_BARCODE_DPI=<int>
    # During barcode detection every page from a PDF document needs to be converted to an image.
    # A dpi value can be specified in the conversion process. Default is 300. If the detection of small barcodes
    # fails a bigger dpi value i.e. 600 can fix the issue. Try using in combination with
    # PAPERLESS_CONSUMER_BARCODE_UPSCALE bigger than 1.0.
    # Defaults to "300"
    barcodeDpi:

    # PAPERLESS_CONSUMER_BARCODE_STRING=<string>
    # Defines the string to be detected as a separator barcode. If paperless is used with the PATCH-T
    # separator pages, users shouldn't change this.
    # Defaults to "PATCHT"
    barcodeString:

    # PAPERLESS_CONSUMER_BARCODE_UPSCALE=<float>
    # Defines the upscale factor used in barcode detection. Improves the detection of small barcodes,
    # i.e. with a value of 1.5 by upscaling the document before the detection process. Upscaling will only
    # take place if value is bigger than 1.0. Otherwise upscaling will not be performed to save resources.
    # Try using in combination with PAPERLESS_CONSUMER_BARCODE_DPI set to a value higher than default.
    # Defaults to 0.0
    barcodeUpscale:

    # PAPERLESS_CONSUMER_ENABLE_BARCODES=<bool>
    # Enables the scanning and page separation based on detected barcodes. This allows for scanning and adding
    # multiple documents per uploaded file, which are separated by one or multiple barcode pages.
    # For ease of use, it is suggested to use a standardized separation page, e.g. here.
    # If no barcodes are detected in the uploaded file, no page separation will happen.
    # The original document will be removed and the separated pages will be saved as pdf.
    # See additional information in the advanced usage documentation
    # Defaults to false.
    enabled:

    # PAPERLESS_CONSUMER_ENABLE_ASN_BARCODE=<bool>
    # Enables the detection of barcodes in the scanned document and setting the ASN (archive serial number)
    # if a properly formatted barcode is detected.
    # The barcode must consist of a (configurable) prefix and the ASN to be set, for instance ASN00123.
    # The content after the prefix is cleaned of non-numeric characters.
    # This option is compatible with barcode page separation, since pages will be split up before reading the ASN.
    # If no ASN barcodes are detected in the uploaded file, no ASN will be set. If a barcode with an existing ASN
    # is detected, the document will not be consumed and an error logged.
    # Defaults to false.
    enableAsnBarcode:

    # PAPERLESS_CONSUMER_ENABLE_TAG_BARCODE=<bool>
    # Enables the detection of barcodes in the scanned document and assigns or creates tags if a properly formatted
    # barcode is detected.
    # The barcode must match one of the (configurable) regular expressions. If the barcode text contains ',' (comma),
    # it is split into multiple barcodes which are individually processed for tagging.
    # Matching is case insensitive.
    # Defaults to false.
    enableTagBarcode:

    # PAPERLESS_CONSUMER_BARCODE_MAX_PAGES=<int>
    # Because barcode detection is a computationally-intensive operation, this setting limits the detection of
    # barcodes to a number of first pages. If your scanner has a limit for the number of pages that can be scanned
    # it would be sensible to set this as the limit here.
    # Defaults to "0", allowing all pages to be checked for barcodes.
    maxPages:

    # PAPERLESS_CONSUMER_BARCODE_RETAIN_SPLIT_PAGES=<bool>
    # If set to true, all pages that are split by a barcode (such as PATCHT) will be kept.
    # Defaults to false.
    retainSplitPages:

    # PAPERLESS_CONSUMER_TAG_BARCODE_MAPPING=<json dict>
    # Defines a dictionary of filter regex and substitute expressions.
    # Syntax: {"<regex>": "<substitute>" [,...]]}
    # A barcode is considered for tagging if the barcode text matches at least one of the provided pattern.
    # If a match is found, the rule is applied. This allows very versatile reformatting and mapping of barcode
    # pattern to tag values.
    # If a tag is not found it will be created.
    # Defaults to: {"TAG:(.*)": "\\g<1>"} which defines - a regex TAG:(.*) which includes barcodes beginning
    # with TAG: followed by any text that gets stored into match group #1 and - a substitute \\g<1> that replaces
    # the original barcode text by the content in match group #1.
    # Consequently, the tag is the barcode text without its TAG: prefix.
    # More examples:
    # {"ASN12.*": "JOHN", "ASN13.*": "SMITH"} for example maps - ASN12nnnn barcodes to the tag JOHN and - ASN13nnnn
    # barcodes to the tag SMITH.
    # {"T-J": "JOHN", "T-S": "SMITH", "T-D": "DOE"} directly maps - T-J barcodes to the tag JOHN, - T-S barcodes
    # to the tag SMITH and - T-D barcodes to the tag DOE.
    # Please refer to the Python regex documentation for more information.
    tagBarcodeMapping:

    # PAPERLESS_CONSUMER_BARCODE_TIFF_SUPPORT=<bool>
    # Whether TIFF image files should be scanned for barcodes. This will automatically convert any TIFF image(s)
    # to pdfs for later processing. This only has an effect, if PAPERLESS_CONSUMER_ENABLE_BARCODES has been enabled.
    # Defaults to false.
    tiffSupport:

  collation:
    doubleSided:
      # PAPERLESS_CONSUMER_ENABLE_COLLATE_DOUBLE_SIDED=<bool>
      # Enables automatic collation of two single-sided scans into a double-sided document.
      # This is useful if you have an automatic document feeder that only supports single-sided scans, but you need to scan a double-sided document. If your ADF supports double-sided scans natively, you do not need this feature.
      # PAPERLESS_CONSUMER_RECURSIVE must be enabled for this to work.
      # For more information, read the corresponding section in the advanced documentation.
      # Defaults to false.
      enabled:

      # PAPERLESS_CONSUMER_COLLATE_DOUBLE_SIDED_SUBDIR_NAME=<str>
      # The name of the subdirectory that the collate feature expects documents to arrive.
      # This only has an effect if PAPERLESS_CONSUMER_ENABLE_COLLATE_DOUBLE_SIDED has been enabled.
      # Note that Paperless will not automatically create the directory.
      # Defaults to "double-sided".
      subdirName:

      # PAPERLESS_CONSUMER_COLLATE_DOUBLE_SIDED_TIFF_SUPPORT=<bool>
      # Whether TIFF image files should be supported when collating documents. This will automatically
      # convert any TIFF image(s) to pdfs for later processing. This only has an effect if
      # PAPERLESS_CONSUMER_ENABLE_COLLATE_DOUBLE_SIDED has been enabled.
      # Defaults to false.
      tiffSupport:

  container:
    userMap:
      # USERMAP_GID=<gid>
      # The ID of the paperless Group in the container. Set this to your actual group ID on the host system,
      # which you can get by executing "id -g". Paperless will change ownership on its folders to this group,
      # so you need to get this right in order to be able to write to the consumption directory.
      # Defaults to 1000.
      gid:

      # USERMAP_UID=<uid>
      # The ID of the paperless user in the container. Set this to your actual user ID on the host system,
      # which you can get by executing "id -u". Paperless will change ownership on its folders to this user,
      # so you need to get this right in order to be able to write to the consumption directory.
      # Defaults to 1000.
      uid:

    webServer:
      # PAPERLESS_WEBSERVER_WORKERS=<num>
      # The number of worker processes the webserver should spawn. More worker processes usually result in the
      # front end to load data much quicker. However, each worker process also loads the entire application into
      # memory separately, so increasing this value will increase RAM usage.
      # Defaults to 1.
      workers:

  documentConsumption:
    # PAPERLESS_CONSUMER_BARCODE_SCANNER=<string>
    # Sets the barcode scanner used for barcode functionality.
    # Currently, "PYZBAR" (the default) or "ZXING" might be selected. If you have problems that your
    # Barcodes/QR-Codes are not detected (especially with bad scan quality and/or small codes), try the other one.
    barcodeScanner:

    # PAPERLESS_DATE_ORDER=<format>
    # Paperless will try to determine the document creation date from its contents. Specify the date format Paperless
    # should expect to see within your documents.
    # This option defaults to DMY which translates to day first, month second, and year last order.
    # Characters D, M, or Y can be shuffled to meet the required order.
    dateOrder:

    # PAPERLESS_CONSUMER_DELETE_DUPLICATES=<bool>
    # When the consumer detects a duplicate document, it will not touch the original document. This default behavior can be changed here.
    # Defaults to false.
    deleteDuplicates:

    # PAPERLESS_CONSUMER_DISABLE
    # If set (to anything), this completely disables the directory-based consumer in docker.
    # If you don't plan to consume documents via the consumption directory, you can disable the consumer
    # to save resources.
    disableConsumer:

    # PAPERLESS_ENABLE_GPG_DECRYPTOR=<bool>
    # Enable or disable the GPG decryptor for encrypted emails. See GPG Decryptor for more information.
    # Defaults to false.
    enableGpgDecryptor:

    # PAPERLESS_FILENAME_DATE_ORDER=<format>
    # Paperless will check the document text for document date information. Use this setting to enable checking
    # the document filename for date information. The date order can be set to any option as specified in
    # https://dateparser.readthedocs.io/en/latest/settings.html#date-order. The filename will be checked first,
    # and if nothing is found, the document text will be checked as normal.
    # A date in a filename must have some separators (., ,, -, /, etc) for it to be parsed.
    # Defaults to none, which disables this feature.
    filenameDateOrder:

    # PAPERLESS_IGNORE_DATES=<string>
    # Paperless parses a document's creation date from filename and file content. You may specify a comma separated
    # list of dates that should be ignored during this process. This is useful for special dates (like date of birth)
    # that appear in documents regularly but are very unlikely to be the document's creation date.
    # The date is parsed using the order specified in PAPERLESS_DATE_ORDER
    # Defaults to an empty string to not ignore any dates.
    ignoreDates:

    # PAPERLESS_CONSUMER_IGNORE_PATTERNS=<json>
    # By default, paperless ignores certain files and folders in the consumption directory, such as system files
    # created by the Mac OS or hidden folders some tools use to store data.
    # This can be adjusted by configuring a custom json array with patterns to exclude.
    # For example, .DS_STORE/* will ignore any files found in a folder named .DS_STORE, including .DS_STORE/bar.pdf
    # and foo/.DS_STORE/bar.pdf
    # A pattern like ._* will ignore anything starting with ._, including: ._foo.pdf and ._bar/foo.pdf
    # Defaults to [".DS_Store", ".DS_STORE", "._*", ".stfolder/*", ".stversions/*", ".localized/*", "desktop.ini",
    # "@eaDir/*", "Thumbs.db"].
    ignorePatterns:

    iNotify:
      # PAPERLESS_CONSUMER_INOTIFY_DELAY=<num>
      # Sets the time in seconds the consumer will wait for additional events from inotify before the consumer
      # will consider a file ready and begin consumption. Certain scanners or network setups may generate multiple
      # events for a single file, leading to multiple consumers working on the same file.
      # Configure this to prevent that.
      # Defaults to 0.5 seconds.
      delay:

    # PAPERLESS_NUMBER_OF_SUGGESTED_DATES=<num>
    # Paperless searches an entire document for dates. The first date found will be used as the initial value for
    # the created date. When this variable is greater than 0 (or left to its default value), paperless will also
    # suggest other dates found in the document, up to a maximum of this setting. Note that duplicates will be
    # removed, which can result in fewer dates displayed in the frontend than this setting value.
    # The task to find all dates can be time-consuming and increases with a higher (maximum) number of suggested
    # dates and slower hardware.
    # Defaults to 3. Set to 0 to disable this feature.
    numSuggestedDates:

    # PAPERLESS_POST_CONSUME_SCRIPT=<filename>
    # After a document is consumed, Paperless can trigger an arbitrary script if you like.
    # This script will be provided data for it to work with via the environment.
    # For more information, take a look at Post-consumption script.
    # The default is blank, which means nothing will be executed.
    postConsumeScript:

    polling:
      # PAPERLESS_CONSUMER_POLLING_DELAY=<num>
      # If consumer polling is enabled, sets the delay in seconds between each check (above) paperless will
      # do while waiting for a file to remain unmodified.
      # Defaults to 5.
      delay:

      # PAPERLESS_CONSUMER_POLLING=<num>
      # If paperless won't find documents added to your consume folder, it might not be able to automatically
      # detect filesystem changes. In that case, specify a polling interval in seconds here, which will then
      # cause paperless to periodically check your consumption directory for changes. This will also disable
      # listening for file system changes with inotify.
      # Defaults to 0, which disables polling and uses filesystem notifications.
      interval:

      # PAPERLESS_CONSUMER_POLLING_RETRY_COUNT=<num>
      # If consumer polling is enabled, sets the maximum number of times paperless will check for a file to remain
      # unmodified. If a file's modification time and size are identical for two consecutive checks, it will be
      # consumed.
      # Defaults to 5.
      retryCount:

    # PAPERLESS_PRE_CONSUME_SCRIPT=<filename>
    # After some initial validation, Paperless can trigger an arbitrary script if you like before beginning
    # consumption. This script will be provided data for it to work with via the environment.
    # For more information, take a look at pre-consumption script.
    # The default is blank, which means nothing will be executed.
    preConsumeScript:

    # PAPERLESS_CONSUMER_RECURSIVE=<bool>
    # Enable recursive watching of the consumption directory. Paperless will then pickup files from files in
    # subdirectories within your consumption directory as well.
    # Defaults to false.
    recursive:

    # PAPERLESS_CONSUMER_SUBDIRS_AS_TAGS=<bool>
    # Set the names of subdirectories as tags for consumed files. E.g. <CONSUMPTION_DIR>/foo/bar/file.pdf
    # will add the tags "foo" and "bar" to the consumed file. Paperless will create any tags that don't exist yet.
    # This is useful for sorting documents with certain tags such as car or todo prior to consumption.
    # These folders won't be deleted.
    # PAPERLESS_CONSUMER_RECURSIVE must be enabled for this to work.
    # Defaults to false.
    subdirsAsTags:

  email:
    # PAPERLESS_EMAIL_FROM=<str>
    # Defaults to PAPERLESS_EMAIL_HOST_USER if not set.
    from:

    # PAPERLESS_EMAIL_HOST=<str>
    # Defaults to 'localhost'.
    host:
    
    # PAPERLESS_EMAIL_HOST_PASSWORD=<str>
    # Defaults to ''.
    password:
    
    # PAPERLESS_EMAIL_PORT=<int>
    # Defaults to port 25.
    port:
    
    # PAPERLESS_EMAIL_HOST_USER=<str>
    # Defaults to ''.
    user:
    
    # PAPERLESS_EMAIL_USE_SSL=<bool>
    # Defaults to false.
    useSsl:
    
    # PAPERLESS_EMAIL_USE_TLS=<bool>
    # Defaults to false.
    useTls:

  filenames:
    # PAPERLESS_FILENAME_FORMAT=<format>
    # Changes the filenames paperless uses to store documents in the media directory.
    # See File name handling for details.
    # Default is none, which disables this feature.
    format:

    # PAPERLESS_FILENAME_FORMAT_REMOVE_NONE=<bool>
    # Tells paperless to replace placeholders in PAPERLESS_FILENAME_FORMAT that would resolve
    # to 'none' to be omitted from the resulting filename. This also holds true for directory names.
    # See File name handling for details.
    # Defaults to false which disables this feature.
    formatRemoveNone:

  frontEnd:
    # PAPERLESS_APP_TITLE=<str>
    # If set, overrides the default name "Paperless-ngx"
    title:

    # PAPERLESS_APP_LOGO=<path>
    # Path to an image file in the /media/logo directory, must include 'logo', e.g. /logo/Atari_logo.svg
    logo:

  hosting:
    # PAPERLESS_SECRET_KEY=<key>
    # Paperless uses this to make session tokens. If you expose paperless on the internet,
    # you need to change this, since the default secret is well known.
    # Use any sequence of characters. The more, the better. You don't need to remember this.
    # Just face-roll your keyboard.
    secretKey:

    # PAPERLESS_USE_X_FORWARD_HOST=<bool>
    # Configures the Django setting USE_X_FORWARDED_HOST which may be needed for hosting behind a proxy.
    # Defaults to false.
    useXForwardHost: true

    # PAPERLESS_USE_X_FORWARD_PORT=<bool>
    # Configures the Django setting USE_X_FORWARDED_PORT which may be needed for hosting behind a proxy.
    # Defaults to False
    useXForwardPort: true

  incomingMail:
    oAuth:
      # PAPERLESS_OAUTH_CALLBACK_BASE_URL=<str>
      # The base URL for the OAuth callback. This is used to construct the full URL for the OAuth callback.
      # This should be the URL that the Paperless instance is accessible at. If not set, defaults to the
      # PAPERLESS_URL setting. At least one of these settings must be set to enable OAuth Email setup.
      # Defaults to none (thus will use PAPERLESS_URL).
      # Note: This setting only applies to OAuth Email setup (not to the SSO setup).
      callbackBaseUrl:

      # PAPERLESS_GMAIL_OAUTH_CLIENT_ID=<str>
      # The OAuth client ID for Gmail. This is required for Gmail OAuth Email setup. See OAuth Email Setup
      # for more information.
      # Defaults to none.
      gMailOAuthClientId:

      # PAPERLESS_GMAIL_OAUTH_CLIENT_SECRET=<str>
      # The OAuth client secret for Gmail. This is required for Gmail OAuth Email setup. See OAuth Email Setup
      # for more information.
      # Defaults to none.
      gMailOAuthClientSecret:

      # PAPERLESS_OUTLOOK_OAUTH_CLIENT_ID=<str>
      # The OAuth client ID for Outlook. This is required for Outlook OAuth Email setup. See OAuth Email Setup
      # for more information.
      # Defaults to none.
      outlookOAuthClientId:

      # PAPERLESS_OUTLOOK_OAUTH_CLIENT_SECRET=<str>
      # The OAuth client secret for Outlook. This is required for Outlook OAuth Email setup. See OAuth Email Setup
      # for more information.
      # Defaults to none.
      outlookOAuthClientSecret:

  ocr:
    # PAPERLESS_OCR_CLEAN=<mode>
    # Tells paperless to use unpaper to clean any input document before sending it to tesseract.
    # This uses more resources, but generally results in better OCR results. The following modes are available:
    # - clean: Apply unpaper.
    # - clean-final: Apply unpaper, and use the cleaned images to build the output file instead of
    #                the original images.
    # - none: Do not apply unpaper.
    # Defaults to clean.
    # Note: clean-final is incompatible with ocr mode redo. When both clean-final and the ocr mode redo
    #       is configured, clean is used instead.
    clean:

    # PAPERLESS_OCR_COLOR_CONVERSION_STRATEGY=<RGB>
    # Controls the Ghostscript color conversion strategy when creating the archive file. This setting will
    # only be utilized if the output is a version of PDF/A.
    # Valid options are CMYK, Gray, LeaveColorUnchanged, RGB or UseDeviceIndependentColor.
    # You can find more on the settings here in the Ghostscript documentation.
    # WARNING: Utilizing some of the options may result in errors when creating archive files from PDFs.
    colorConversionStrategy:

    # PAPERLESS_OCR_DESKEW=<bool>
    # Tells paperless to correct skewing (slight rotation of input images mainly due to improper scanning)
    # Defaults to true, which enables this feature.
    # Note: Deskewing is incompatible with ocr mode redo.
    #       Deskewing will get disabled automatically if redo is used as the ocr mode.
    deskew:

    # PAPERLESS_OCR_IMAGE_DPI=<num>
    # Paperless will OCR any images you put into the system and convert them into PDF documents.
    # This is useful if your scanner produces images. In order to do so, paperless needs to know the DPI of
    # the image. Most images from scanners will have this information embedded and paperless will detect and
    # use that information. In case this fails, it uses this value as a fallback.
    # Set this to the DPI your scanner produces images at.
    # Defaults to unset, which will automatically calculate image DPI so that the produced PDF documents
    # are A4 sized.
    imageDpi:

    # PAPERLESS_OCR_LANGUAGE=<lang>
    # Customize the language that paperless will attempt to use when parsing documents.
    # It should be a 3-letter code, see the list of languages Tesseract supports.
    # Set this to the language most of your documents are written in.
    # This can be a combination of multiple languages such as deu+eng, in which case Tesseract will use
    # whatever language matches best. Keep in mind that Tesseract uses much more CPU time with multiple
    # languages enabled.
    # If you are including languages that are not installed by default, you will need to also set
    # PAPERLESS_OCR_LANGUAGES for docker deployments or install the tesseract language packages manually
    # for bare metal installations.
    # Defaults to "eng".
    language:

    # PAPERLESS_OCR_MAX_IMAGE_PIXELS=<num>
    # Paperless will raise a warning when OCRing images which are over this limit and will not OCR images
    # which are more than twice this limit. Note this does not prevent the document from being consumed,
    # but could result in missing text content.
    # If unset, will default to the value determined by Pillow.
    # Setting this value to 0 will entirely disable the limit. See the below warning.
    # Note: Increasing this limit could cause Paperless to consume additional resources when consuming a file.
    #       Be sure you have sufficient system resources.
    # WARNING: The limit is intended to prevent malicious files from consuming system resources and causing
    #          crashes and other errors. Only change this value if you are certain your documents are not
    #          malicious and you need the text which was not OCRed
    maxImagePixels:

    # PAPERLESS_OCR_MODE=<mode>
    # Tell paperless when and how to perform ocr on your documents. Three modes are available:
    # - skip: Paperless skips all pages and will perform ocr only on pages where no text is present. 
    #         This is the safest option.
    # - redo: Paperless will OCR all pages of your documents and attempt to replace any existing text
    #         layers with new text. This will be useful for documents from scanners that already performed
    #         OCR with insufficient results. It will also perform OCR on purely digital documents.
    #         This option may fail on some documents that have features that cannot be removed, such as forms.
    #         In this case, the text from the document is used instead.
    # - force: Paperless rasterizes your documents, converting any text into images and puts the OCRed text on
    #          top. This works for all documents, however, the resulting document may be significantly larger
    #          and text won't appear as sharp when zoomed in.
    # The default is skip, which only performs OCR when necessary and always creates archived documents.
    mode:

    # PAPERLESS_OCR_OUTPUT_TYPE=<type>
    # Specify the the type of PDF documents that paperless should produce.
    # - pdf: Modify the PDF document as little as possible.
    # - pdfa: Convert PDF documents into PDF/A-2b documents, which is a subset of the entire PDF specification
    #         and meant for storing documents long term.
    # - pdfa-1, pdfa-2, pdfa-3 to specify the exact version of PDF/A you wish to use.
    # If not specified, pdfa is used. Remember that paperless also keeps the original input file as well as the
    # archived version.
    outputType:

    # PAPERLESS_OCR_PAGES=<num>
    # Tells paperless to use only the specified amount of pages for OCR. Documents with less than the specified
    # amount of pages get OCR'ed completely.
    # Specifying 1 here will only use the first page.
    # The value must be greater than or equal to 1 to be used.
    # When combined with PAPERLESS_OCR_MODE=redo or PAPERLESS_OCR_MODE=force, paperless will not modify any text
    # it finds on excluded pages and copy it verbatim.
    # Defaults to unset, which disables this feature and always uses all pages.
    pages:

    # PAPERLESS_OCR_ROTATE_PAGES=<bool>
    # Tells paperless to correct page rotation (90°, 180° and 270° rotation).
    # If you notice that paperless is not rotating incorrectly rotated pages (or vice versa), try adjusting
    # the threshold up or down (see below).
    # Defaults to true, which enables this feature.
    rotatePages:

    # PAPERLESS_OCR_ROTATE_PAGES_THRESHOLD=<num>
    # Adjust the threshold for automatic page rotation by PAPERLESS_OCR_ROTATE_PAGES. This is an arbitrary
    # value reported by tesseract. "15" is a very conservative value, whereas "2" is a very aggressive option
    # and will often result in correctly rotated pages being rotated as well.
    # Defaults to "12".
    rotatePagesThreshold:

    # PAPERLESS_OCR_SKIP_ARCHIVE_FILE=<mode>
    # Specify when you would like paperless to skip creating an archived version of your documents.
    # This is useful if you don't want to have two almost-identical versions of your documents in the media folder.
    # - never: Never skip creating an archived version.
    # - with_text: Skip creating an archived version for documents that already have embedded text.
    # - always: Always skip creating an archived version.
    # The default is never.
    skipArchiveFile:

  optionalServices:
    # PAPERLESS_TIKA_ENABLED=<bool>
    # Enable (or disable) the Tika parser.
    # Defaults to false.
    tikaEnabled:

  trash:
    # PAPERLESS_EMPTY_TRASH_DELAY=<num>
    # Sets how long in days documents remain in the 'trash' before they are permanently deleted.
    # Defaults to 30 days, minimum of 1 day.
    emptyDelay:

    # PAPERLESS_EMPTY_TRASH_TASK_CRON=<cron expression>
    # Configures the schedule to empty the trash of expired deleted documents.
    # Defaults to :0 1 * * *", once per day.
    emptyTask:

  tweaks:
    # PAPERLESS_APPS=<string>
    # A comma-separated list of Django apps to be included in Django's INSTALLED_APPS.
    # This setting should be used with caution!
    # Defaults to None, which does not add any additional apps.
    apps:

    # PAPERLESS_CONVERT_MEMORY_LIMIT=<num>
    # On smaller systems, or even in the case of Very Large Documents, the consumer may explode, complaining
    # about how it's "unable to extend pixel cache". In such cases, try setting this to a reasonably low value,
    # like 32. The default is to use whatever is necessary to do everything without writing to disk, and units
    # are in megabytes.
    # For more information on how to use this value, you should search the web for "MAGICK_MEMORY_LIMIT".
    # Defaults to 0, which disables the limit.
    convertMemoryLimit:

    cron:
      # PAPERLESS_EMAIL_TASK_CRON=<cron expression>
      # Configures the scheduled email fetching frequency. The value should be a valid crontab(5) expression
      # describing when to run.
      # If set to the string "disable", no emails will be fetched automatically.
      # Defaults to "*/10 * * * *" or every ten minutes.
      emailTask:

      # PAPERLESS_INDEX_TASK_CRON=<cron expression>
      # Configures the scheduled search index update frequency. The value should be a valid crontab(5) expression
      # describing when to run.
      # If set to the string "disable", the search index will not be automatically updated.
      # Defaults to "0 0 * * *"" or daily at midnight.
      indexTask:

      # PAPERLESS_TRAIN_TASK_CRON=<cron expression>
      # Configures the scheduled automatic classifier training frequency. The value should be a valid crontab(5)
      # expression describing when to run.
      # If set to the string "disable", the classifier will not be trained automatically.
      # Defaults to "5 */1 * * *" or every hour at 5 minutes past the hour.
      trainTask:

      # PAPERLESS_SANITY_TASK_CRON=<cron expression>
      # Configures the scheduled sanity checker frequency.
      # If set to the string "disable", the sanity checker will not run automatically.
      # Defaults to "30 0 * * sun" or Sunday at 30 minutes past midnight.
      sanityTask:

    # PAPERLESS_MAX_IMAGE_PIXELS=<number>
    # Configures the maximum size of an image PIL will allow to load without warning or error.
    # If unset, will default to the value determined by Pillow.
    # Defaults to None, which does change the limit
    # WARNING: This limit is designed to prevent denial of service from malicious files.
    #          It should only be raised or disabled in certain circumstances and with great care.
    maxImagePixels:

    # PAPERLESS_TASK_WORKERS=<num>
    # Paperless does multiple things in the background: Maintain the search index, maintain the automatic
    # matching algorithm, check emails, consume documents, etc. This variable specifies how many things it
    # will do in parallel.
    # Defaults to 1
    taskWorkers:

    # PAPERLESS_THREADS_PER_WORKER=<num>
    # Paperless uses multiple threads when consuming documents to speed up OCR. This variable specifies how
    # many pages paperless will process in parallel on a single document.
    # WARNING: Ensure that the product of workers * threads per worker does not exceed your CPU core count 
    #          or else paperless will be extremely slow. If you want paperless to process many documents in
    #          parallel, choose a high worker count. If you want paperless to process very large documents faster,
    #          use a higher thread per worker count.
    threadsPerWorker:

    # PAPERLESS_TIME_ZONE=<timezone>
    # Set the time zone here. See more details on why and how to set it in the Django project documentation
    # for details on how to set it.
    # Defaults to UTC.
    timeZone:

    # PAPERLESS_WORKER_TIMEOUT=<num>
    # Machines with few cores or weak ones might not be able to finish OCR on large documents within the default
    # 1800 seconds. So extending this timeout may prove to be useful on weak hardware setups.
    workerTimeout:

ingress:
  # Put your FQDN for hosting here
  endpoint: paperless.domain.com

  # If using cert-manager.io with a cluster issuer, indicate the name here.
  certManagerClusterIssuer:

  # Indicate the maximum upload size for the proxy.
  maxUploadSize: "150m"

volumes:
  - name: "paperless-consume"
    capacity: "100Mi"
    component: paperless
    storageClassName: ""

  - name: "paperless-data"
    capacity: "100Mi"
    component: paperless
    storageClassName: ""

  - name: "paperless-export"
    capacity: "100Mi"
    component: paperless
    storageClassName: ""

  - name: "paperless-media"
    capacity: "100Mi"
    component: paperless
    storageClassName: ""

  - name: "redis-data"
    capacity: "100Mi"
    component: redis
    storageClassName: ""

paperless:
  deployment:
    image:
      repository: ghcr.io/paperless-ngx/paperless-ngx
    volumes:
      - name: paperless-consume
        mountPath: /usr/src/paperless/consume
      - name: paperless-data
        mountPath: /usr/src/paperless/data
      - name: paperless-export
        mountPath: /usr/src/paperless/export
      - name: paperless-media
        mountPath: /usr/src/paperless/media
  service:
    ports:
      - 8000

redis:
  deployment:
    image:
      repository: docker.io/library/redis
      tag: "7"
    volumes:
      - name: "redis-data"
        mountPath: "/data"
  service:
    ports:
      - 6379

tika:
  deployment:
    image:
      repository: apache/tika
      tag: latest
  service:
    ports:
      - 9998

gotenberg:
  deployment:
    image:
      repository: gotenberg/gotenberg
      tag: "7.10"
  service:
    ports:
      - 3000

networkPolicy:
  # Indicate the K8s namespace to allow ingress from.
  allowIngressFromNamespace: ingress-nginx
